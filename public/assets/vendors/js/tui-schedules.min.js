"use strict";

// Lista global que almacenará los horarios generados
var ScheduleList = [];

// Categorías de horario disponibles ("hito" y "tarea")
var SCHEDULE_CATEGORY = ["milestone", "task"];

// Clase/Constructor para crear un objeto de información de horario
function ScheduleInfo() {
    this.id = null;
    this.calendarId = null;
    this.title = null;
    this.body = null;
    this.location = null;
    this.isAllday = false; // Indica si el evento dura todo el día
    this.start = null; // Hora de inicio
    this.end = null; // Hora de fin
    this.category = ""; // Categoría del evento
    this.dueDateClass = "";
    this.color = null;
    this.bgColor = null;
    this.dragBgColor = null;
    this.borderColor = null;
    this.customStyle = "";
    this.isFocused = false;
    this.isPending = false;
    this.isVisible = true;
    this.isReadOnly = false;
    this.isPrivate = false;
    this.goingDuration = 0;
    this.comingDuration = 0;
    this.recurrenceRule = "";
    this.state = "";
    this.raw = {
        memo: "",
        hasToOrCc: false,
        hasRecurrenceRule: false,
        location: null,
        creator: {
            name: "",
            avatar: "",
            company: "",
            email: "",
            phone: ""
        }
    };
}

// Función para generar el tiempo de inicio y fin del evento
function generateTime(schedule, startRange, endRange) {
    var start = moment(startRange.getTime()); // Convierte el rango de inicio a objeto moment
    var end = moment(endRange.getTime()); // Convierte el rango de fin a objeto moment
    var dateDiff = end.diff(start, "days"); // Diferencia de días entre las dos fechas

    // Definir si el evento es de todo el día
    schedule.isAllday = chance.bool({ likelihood: 30 });
    if (schedule.isAllday) {
        schedule.category = "allday";
    } else if (chance.bool({ likelihood: 30 })) {
        schedule.category = SCHEDULE_CATEGORY[chance.integer({ min: 0, max: 1 })];
        if (schedule.category === SCHEDULE_CATEGORY[1]) {
            schedule.dueDateClass = "morning";
        }
    } else {
        schedule.category = "time";
    }

    // Generar hora de inicio aleatoria dentro del rango
    start.add(chance.integer({ min: 0, max: dateDiff }), "days");
    start.hours(chance.integer({ min: 0, max: 23 }));
    start.minutes(chance.bool() ? 0 : 30);
    schedule.start = start.toDate();

    // Generar hora de fin aleatoria basada en la de inicio
    var tempEnd = moment(start);
    if (schedule.isAllday) {
        tempEnd.add(chance.integer({ min: 0, max: 3 }), "days");
    }
    schedule.end = tempEnd.add(chance.integer({ min: 1, max: 4 }), "hour").toDate();

    // Ajustar duración para eventos de tiempo
    if (!schedule.isAllday && chance.bool({ likelihood: 20 })) {
        schedule.goingDuration = chance.integer({ min: 30, max: 120 });
        schedule.comingDuration = chance.integer({ min: 30, max: 120 });
        if (chance.bool({ likelihood: 50 })) {
            schedule.end = schedule.start;
        }
    }
}

// Función para generar nombres aleatorios de asistentes
function generateNames() {
    var names = [];
    var count = chance.integer({ min: 1, max: 10 }); // Número aleatorio de asistentes
    for (var i = 0; i < count; i += 1) {
        names.push(chance.name());
    }
    return names;
}

// Función para crear un evento aleatorio en el calendario
function generateRandomSchedule(calendar, startRange, endRange) {
    var schedule = new ScheduleInfo();

    // Generar información básica del evento
    schedule.id = chance.guid();
    schedule.calendarId = calendar.id;
    schedule.title = chance.sentence({ words: 3 }); // Título del evento
    schedule.body = chance.bool({ likelihood: 20 }) ? chance.sentence({ words: 10 }) : "";
    schedule.isReadOnly = chance.bool({ likelihood: 20 });

    // Generar tiempos del evento
    generateTime(schedule, startRange, endRange);

    // Otros atributos del evento
    schedule.isPrivate = chance.bool({ likelihood: 10 });
    schedule.location = chance.address();
    schedule.attendees = chance.bool({ likelihood: 70 }) ? generateNames() : [];
    schedule.recurrenceRule = chance.bool({ likelihood: 20 }) ? "Repeated Events" : "";
    schedule.state = chance.bool({ likelihood: 20 }) ? "Free" : "Busy";

    // Estilo de colores
    schedule.color = calendar.color;
    schedule.bgColor = calendar.bgColor;
    schedule.dragBgColor = calendar.dragBgColor;
    schedule.borderColor = calendar.borderColor;

    // Ajustar estilo para eventos de tipo "milestone"
    if (schedule.category === "milestone") {
        schedule.color = schedule.bgColor;
        schedule.bgColor = "transparent";
        schedule.dragBgColor = "transparent";
        schedule.borderColor = "transparent";
    }

    // Información adicional
    schedule.raw.memo = chance.sentence();
    schedule.raw.creator.name = chance.name();
    schedule.raw.creator.avatar = chance.avatar();
    schedule.raw.creator.company = chance.company();
    schedule.raw.creator.email = chance.email();
    schedule.raw.creator.phone = chance.phone();

    // Ajustar duraciones si aplica
    if (chance.bool({ likelihood: 20 })) {
        var duration = chance.minute();
        schedule.goingDuration = duration;
        schedule.comingDuration = duration;
    }

    // Agregar el evento generado a la lista global
    ScheduleList.push(schedule);
}

// Función principal para generar horarios
function generateSchedule(viewType, startRange, endRange) {
    // Vaciar la lista de eventos
    ScheduleList = [];

    // Iterar sobre cada calendario y generar eventos
    CalendarList.forEach(function (calendar) {
        var count = 0;
        var maxCount = 10;

        // Ajustar el número máximo de eventos según el tipo de vista
        if (viewType === "month") {
            maxCount = 3;
        } else if (viewType === "day") {
            maxCount = 4;
        }

        // Generar eventos aleatorios
        for (; count < maxCount; count += 1) {
            generateRandomSchedule(calendar, startRange, endRange);
        }
    });
}
